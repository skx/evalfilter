// Package evalfilter allows running a user-supplied script against an object.
//
// We're constructed with a program, and internally we parse that to an
// abstract syntax-tree, then we walk that tree to generate a series of
// bytecodes.
//
// The bytecode is then executed via the VM-package.
package evalfilter

import (
	"encoding/binary"
	"fmt"
	"strings"

	"github.com/skx/evalfilter/v2/ast"
	"github.com/skx/evalfilter/v2/code"
	"github.com/skx/evalfilter/v2/environment"
	"github.com/skx/evalfilter/v2/lexer"
	"github.com/skx/evalfilter/v2/object"
	"github.com/skx/evalfilter/v2/parser"
	"github.com/skx/evalfilter/v2/vm"
)

// Flags which can be optionally passed to Prepare.
const (
	// Don't run the optimizer when generating bytecode.
	NoOptimize byte = iota

	// Show the optimization steps
	ShowOptimize
)

// Eval is our public-facing structure which stores our state.
type Eval struct {
	// Script holds the script the user submitted in our constructor.
	Script string

	// Environment
	environment *environment.Environment

	// constants compiled
	constants []object.Object

	// bytecode we generate
	instructions code.Instructions

	// the machine we drive
	machine *vm.VM
}

// New creates a new instance of the evaluator.
func New(script string) *Eval {

	//
	// Create our object.
	//
	e := &Eval{
		environment: environment.New(),
		Script:      script,
	}

	//
	// Return it.
	//
	return e
}

// Prepare is the second function the caller must invoke, it compiles
// the user-supplied program to its final-form.
//
// Internally this compilation process walks through the usual steps,
// lexing, parsing, and bytecode-compilation.
func (e *Eval) Prepare(flags ...[]byte) error {

	//
	// Default to optimizing the bytecode.
	//
	optimize := true

	//
	// Default to not dumping that process.
	//
	dump := false

	//
	// But let flags change our behaviour.
	//
	for _, arg := range flags {
		for _, val := range arg {
			if val == NoOptimize {
				optimize = false
			}
			if val == ShowOptimize {
				dump = true
			}
		}
	}

	//
	// Create a lexer.
	//
	l := lexer.New(e.Script)

	//
	// Create a parser using the lexer.
	//
	p := parser.New(l)

	//
	// Parse the program into an AST.
	//
	program := p.ParseProgram()

	//
	// Were there any errors produced by the parser?
	//
	// If so report that.
	//
	if len(p.Errors()) > 0 {
		return fmt.Errorf("\nErrors parsing script:\n" +
			strings.Join(p.Errors(), "\n"))
	}

	//
	// Compile the program to bytecode
	//
	err := e.compile(program)

	//
	// If there were errors then return them.
	//
	if err != nil {
		return err
	}

	//
	// Attempt to optimize the code, running multiple passes until no
	// more changes are possible.
	//
	// We do this so that each optimizer run only has to try one thing
	// at a time.
	//
	passes := 0
	if optimize {

		if dump {
			fmt.Printf("Starting bytecode\n")
			e.Dump()
		}

		for e.optimize() {

			if dump {
				fmt.Printf("\n\nBytecode optimization run %d\n", passes+1)
				e.Dump()
			}
			passes++
		}
	}

	//
	// If we made some changes we'll make a second pass.
	//
	if passes > 0 {

		if dump {
			fmt.Printf("\n\nRemoving NOPs and renumbering\n")
		}

		//
		// Remove any NOPs and update any jump
		// targets.
		//
		e.renumberCode()
		if dump {
			e.Dump()
		}

		//
		// If we have zero jumps then we can
		// truncate the bytecode at the time we
		// find the first "Return" instruction.
		//
		if dump {
			fmt.Printf("\n\nRemoving unreachable code\n")
		}
		e.removeDead()
		if dump {
			e.Dump()
		}
	}

	//
	// Now we're done, construct a VM with the bytecode and constants
	// we've created - as well as any function pointers and variables
	// which we were given.
	//
	e.machine = vm.New(e.constants, e.instructions, e.environment)

	//
	// All done; no errors.
	//
	return nil
}

// optimize updates the generated byecode to be more efficient, if it can.
//
// We're trying to fold "maths" here.  Given "2 * 3" we'll
// expect that to be encoded as:
//
//  000000 OpPush 2
//  000003 OpPush 3
//  000006 OpMul
//
// That can be replaced by "OpPush 6", "NOP", "NOP", "NOP", & "NOP".
//
func (e *Eval) optimize() bool {

	//
	// Constants we've seen - and their offsets within the
	// bytecode array.
	//
	type Constants struct {
		// offset is where we found this constant instruction.
		offset int

		// value is the (integer) constant value refered to.
		value int
	}

	//
	// We're going to walk over the bytecode from start to
	// finish.
	//
	ip := 0
	ln := len(e.instructions)

	//
	// Previous opcode.
	//
	prevOp := code.OpNop

	//
	// Keep track of adjacent values here.
	//
	var args []Constants

	//
	// Walk the bytecode.
	//
	for ip < ln {

		//
		// Get the next opcode
		//
		op := code.Opcode(e.instructions[ip])

		//
		// Find out how long it is.
		//
		opLen := code.Length(op)

		//
		// If the opcode is more than a single byte long
		// we read the argument here.
		//
		opArg := 0
		if opLen > 1 {

			//
			// Note in the future we might have to cope
			// with opcodes with more than a single argument,
			// and they might be different sizes.
			//
			opArg = int(binary.BigEndian.Uint16(e.instructions[ip+1 : ip+3]))
		}

		//
		// Now we do the magic.
		//
		switch op {

		case code.OpJumpIfFalse:

			//
			// If the previous opcode was "OpTrue" then
			// the jump is pointless.
			//
			if prevOp == code.OpTrue {

				// wipe the previous instruction, (OpTrue)
				e.instructions[ip-1] = byte(code.OpNop)

				// wipe this jump
				e.instructions[ip] = byte(code.OpNop)
				e.instructions[ip+1] = byte(code.OpNop)
				e.instructions[ip+2] = byte(code.OpNop)

				return true
			}

			//
			// If the previous opcode was "OpFalse" then
			// the jump is always going to be taken.
			//
			// So remove the OpFalse, and make the jump
			// unconditional
			//
			if prevOp == code.OpFalse {

				// wipe the previous instruction, (OpFalse)
				e.instructions[ip-1] = byte(code.OpNop)

				// This jump is now unconditional
				e.instructions[ip] = byte(code.OpJump)

				return true
			}

		case code.OpPush:

			//
			// If we see a constant being pushed we
			// add that to our list tracking such things.
			//
			args = append(args, Constants{offset: ip, value: opArg})

		case code.OpNop:

			//
			// If we see a OpNop instruction that might
			// be as a result of previous optimization
			//
			// We're going to pretend we didn't see a
			// thing.
			//

		case code.OpEqual, code.OpNotEqual:

			//
			// Comparision-tests.
			//
			// If we have two (constant) arguments then
			// we can collapse the test into a simple "True"
			// or "False"
			//
			// If we didn't then it is something we
			// should leave alone.
			//
			if len(args) >= 2 {

				// Get the arguments to the comparision
				a := args[len(args)-1]
				b := args[len(args)-2]

				// Replace the first argument with nop
				e.instructions[a.offset] = byte(code.OpNop)
				e.instructions[a.offset+1] = byte(code.OpNop)
				e.instructions[a.offset+2] = byte(code.OpNop)

				// Replace the second argument with nop
				e.instructions[b.offset] = byte(code.OpNop)
				e.instructions[b.offset+1] = byte(code.OpNop)
				e.instructions[b.offset+2] = byte(code.OpNop)

				//
				// Now we can replace the comparision
				// instruction with either "True" or "False"
				// depending on whether the constant values
				// match.
				//
				if op == code.OpEqual {
					if a.value == b.value {
						e.instructions[ip] = byte(code.OpTrue)
					} else {
						e.instructions[ip] = byte(code.OpFalse)
					}
				}
				if op == code.OpNotEqual {
					if a.value != b.value {
						e.instructions[ip] = byte(code.OpTrue)
					} else {
						e.instructions[ip] = byte(code.OpFalse)
					}
				}

				// Made a change to the bytecode.
				return true
			}

			// reset our argument counters.
			args = nil

		case code.OpMul, code.OpAdd, code.OpSub, code.OpDiv:

			//
			// Primitive maths operation.
			//
			// If we have two (constant) arguments then
			// we can collapse the maths operation into
			// the result directly.
			//
			// i.e. "OpPush 1", "OpPush 3", "OpAdd" can
			// become "OpPush 4" with a series of NOps.
			//
			// If we didn't then it is something we
			// should leave alone.
			//
			if len(args) >= 2 {

				// Get the two arguments
				a := args[len(args)-1]
				b := args[len(args)-2]

				// Replace the first constant
				// load with the result of the operation.
				if op == code.OpMul {
					e.changeOperand(a.offset, a.value*b.value)
				}
				if op == code.OpAdd {
					e.changeOperand(a.offset, a.value+b.value)
				}
				if op == code.OpSub {
					e.changeOperand(a.offset, b.value-a.value)
				}
				if op == code.OpDiv {
					e.changeOperand(a.offset, b.value/a.value)
				}

				// Replace the second argument-load with nop
				e.instructions[b.offset] = byte(code.OpNop)
				e.instructions[b.offset+1] = byte(code.OpNop)
				e.instructions[b.offset+2] = byte(code.OpNop)

				// and finally replace the math-operation
				// itself with a Nop.
				e.instructions[ip] = byte(code.OpNop)

				// We changed something, so we stop now.
				return true
			}

			// reset our argument counters.
			args = nil

		default:

			//
			// If we get here then we've found an instruction
			// that wasn't a constant load, and wasn't something
			// we can fold.
			//
			// So we have to reset our list of constants
			// because we've found something we can't
			// optimize, rewrite, or improve.
			//
			// Shame.
			//
			args = nil
		}

		//
		// Continue to the next instruction.
		//
		ip += opLen

		//
		// Save the previous opcode.
		//
		prevOp = op
	}

	//
	// If we get here we walked all the way over our bytecode
	// and made zero changes.
	//
	return false
}

// renumberCode removes any inline NOP instructions.
//
// It also rewrites the destinations for jumps as appropriate, to
// cope with the changed offsets.
func (e *Eval) renumberCode() {

	//
	// Start.
	//
	ip := 0
	ln := len(e.instructions)

	//
	// Temporary instructions.
	//
	var tmp code.Instructions

	//
	// Map from old offset to new offset.
	//
	rewrite := make(map[int]int)

	//
	// Walk the bytecode.
	//
	for ip < ln {

		op := code.Opcode(e.instructions[ip])
		opLen := code.Length(op)
		opArg := 0
		if opLen > 1 {
			opArg = int(binary.BigEndian.Uint16(e.instructions[ip+1 : ip+3]))
		}

		//
		// Now we do the magic.
		//
		switch op {

		case code.OpNop:
			// Do nothing.  Appropriate.

		default:

			//
			// Append the instruction(s)
			// to the temporary list.
			//
			// Record our new offset
			//
			//  IP has the current offset.
			//
			//  The new/changed offset will be the current
			// position - i.e. the length of the existing
			// instruction set.  Before we add it.
			//
			rewrite[ip] = len(tmp)

			//
			// Copy the instruction.
			//
			tmp = append(tmp, byte(op))

			//
			// Copy any argument.
			//
			if opLen > 1 {
				b := make([]byte, 2)
				binary.BigEndian.PutUint16(b, uint16(opArg))

				tmp = append(tmp, b...)
			}
		}
		ip += opLen
	}

	//
	// If we've done this correctly we've now got a temporary
	// program with no NOPs.   We now need to patch up
	// the jump targets
	//
	ip = 0
	ln = len(tmp)
	for ip < ln {

		// Get the instruction.
		op := code.Opcode(tmp[ip])

		// And its length
		opLen := code.Length(op)

		// Get the optional argument
		opArg := 0
		if opLen > 1 {
			opArg = int(binary.BigEndian.Uint16(tmp[ip+1 : ip+3]))
		}

		//
		// Now we do the magic.
		//
		switch op {

		// If this was a jump we'll have to change
		// the target.
		//
		// We use the rewrite map we already made,
		// which contains "old -> new".
		//
		case code.OpJump, code.OpJumpIfFalse:

			// The old destination is in "opArg".
			//
			// So the new one `rewrite[old]`
			//
			newDst := rewrite[opArg]

			// Make into a two-byte pair.
			b := make([]byte, 2)
			binary.BigEndian.PutUint16(b, uint16(newDst))

			// Update in-place
			tmp[ip+1] = b[0]
			tmp[ip+2] = b[1]

		default:
		}
		ip += opLen
	}

	//
	// Replace the instructions.
	//
	e.instructions = tmp
}

// removeDead does the bare minimum.
//
// If a script has no Jumps in it we can remove all NOP instructions,
// and stop processing at the first Return.
func (e *Eval) removeDead() {

	//
	// Start.
	//
	ip := 0
	ln := len(e.instructions)

	//
	// Temporary instructions.
	//
	var tmp code.Instructions

	run := true

	//
	// Walk the bytecode.
	//
	for ip < ln && run {

		//
		// Get the next opcode
		//
		op := code.Opcode(e.instructions[ip])

		//
		// Find out how long it is.
		//
		opLen := code.Length(op)

		//
		// If the opcode is more than a single byte long
		// we read the argument here.
		//
		opArg := 0
		if opLen > 1 {

			//
			// Note in the future we might have to cope
			// with opcodes with more than a single argument,
			// and they might be different sizes.
			//
			opArg = int(binary.BigEndian.Uint16(e.instructions[ip+1 : ip+3]))
		}

		//
		// Now we do the magic.
		//
		switch op {

		case code.OpJumpIfFalse, code.OpJump:
			return

		case code.OpReturn:

			// Stop once we've seen the first return
			run = false

			tmp = append(tmp, byte(code.OpReturn))

		case code.OpNop:
			// NOP
		default:

			tmp = append(tmp, byte(op))
			if opLen > 1 {

				// Make a buffer for the arg
				b := make([]byte, 2)
				binary.BigEndian.PutUint16(b, uint16(opArg))

				// append
				tmp = append(tmp, b...)
			}
		}
		ip += opLen
	}

	//
	// Replace the instructions.
	//
	e.instructions = tmp
}

// Dump causes our bytecode to be dumped.
//
// This is used by the `evalfilter` CLI-utility, but it might be useful
// to consumers of our library.
func (e *Eval) Dump() error {

	i := 0
	fmt.Printf("Bytecode:\n")

	for i < len(e.instructions) {

		// opcode
		op := e.instructions[i]

		// opcode length
		opLen := code.Length(code.Opcode(op))

		// opcode as a string
		str := code.String(code.Opcode(op))

		fmt.Printf("  %06d\t%14s", i, str)

		// show arg
		if op < byte(code.OpCodeSingleArg) {

			arg := binary.BigEndian.Uint16(e.instructions[i+1 : i+3])
			fmt.Printf("\t%d", arg)

			//
			// Show the values, as comments, to make the
			// bytecode more human-readable.
			//
			if code.Opcode(op) == code.OpConstant {
				fmt.Printf("\t// load constant: %v", e.constants[arg])
			}
			if code.Opcode(op) == code.OpLookup {
				fmt.Printf("\t// lookup field: %v", e.constants[arg])
			}
			if code.Opcode(op) == code.OpCall {
				fmt.Printf("\t// call function with %d arg(s)", arg)
			}
		}

		fmt.Printf("\n")

		i += opLen
	}

	// Show constants, if any are present.
	if len(e.constants) > 0 {
		fmt.Printf("\n\nConstants:\n")
		for i, n := range e.constants {
			fmt.Printf("  %06d Type:%s Value:%s Dump:%v\n", i, n.Type(), n.Inspect(), n)
		}
	}

	return nil
}

// Run takes the program which was passed in the constructor, and
// executes it.
//
// The supplied object will be used for performing dynamic field-lookups, etc.
func (e *Eval) Run(obj interface{}) (bool, error) {

	//
	// Launch the program in the VM.
	//
	out, err := e.machine.Run(obj)

	//
	// Error executing?  Report that.
	//
	if err != nil {
		return false, err
	}

	//
	// Is the return-value an error?  If so report that.
	//
	if out.Type() == object.ERROR {
		return false, fmt.Errorf("%s", out.Inspect())
	}

	//
	// Otherwise convert the result to a boolean, and return.
	//
	return out.True(), err

}

// AddFunction exposes a golang function from your host application
// to the scripting environment.
//
// Once a function has been added it may be used by the filter script.
func (e *Eval) AddFunction(name string, fun interface{}) {
	e.environment.SetFunction(name, fun)
}

// SetVariable adds, or updates a variable which will be available
// to the filter script.
func (e *Eval) SetVariable(name string, value object.Object) {
	e.environment.Set(name, value)
}

// GetVariable retrieves the contents of a variable which has been
// set within a user-script.
//
// If the variable hasn't been set then the null-value will be returned.
func (e *Eval) GetVariable(name string) object.Object {
	value, ok := e.environment.Get(name)
	if ok {
		return value
	}
	return &object.Null{}
}

// compile is core-code for converting the AST into a series of bytecodes.
func (e *Eval) compile(node ast.Node) error {

	switch node := node.(type) {

	case *ast.Program:
		for _, s := range node.Statements {
			err := e.compile(s)
			if err != nil {
				return err
			}
		}

	case *ast.BlockStatement:
		for _, s := range node.Statements {
			err := e.compile(s)
			if err != nil {
				return err
			}
		}

	case *ast.BooleanLiteral:
		if node.Value {
			e.emit(code.OpTrue)
		} else {
			e.emit(code.OpFalse)
		}

	case *ast.FloatLiteral:
		str := &object.Float{Value: node.Value}
		e.emit(code.OpConstant, e.addConstant(str))

	case *ast.IntegerLiteral:

		// Get the value of the literal
		v := node.Value

		// If this is an integer between 0 & 65535 we
		// can push it naturally.
		if v%1 == 0 && v >= 0 && v <= 65534 {
			e.emit(code.OpPush, int(v))
		} else {

			//
			// Otherwise we emit it as a constant
			// to our pool.
			//
			integer := &object.Integer{Value: node.Value}
			e.emit(code.OpConstant, e.addConstant(integer))
		}

	case *ast.StringLiteral:
		str := &object.String{Value: node.Value}
		e.emit(code.OpConstant, e.addConstant(str))

	case *ast.RegexpLiteral:

		// The regexp body
		val := node.Value

		// The regexp flags
		if node.Flags != "" {

			// Which we pretend were part of the body
			// because that is what Golang expects.
			val = "(?" + node.Flags + ")" + val
		}

		// The value + flags
		reg := &object.String{Value: val}
		e.emit(code.OpConstant, e.addConstant(reg))

	case *ast.ReturnStatement:
		err := e.compile(node.ReturnValue)
		if err != nil {
			return err
		}
		e.emit(code.OpReturn)

	case *ast.ExpressionStatement:
		err := e.compile(node.Expression)
		if err != nil {
			return err
		}

	case *ast.InfixExpression:
		err := e.compile(node.Left)
		if err != nil {
			return err
		}

		err = e.compile(node.Right)
		if err != nil {
			return err
		}

		switch node.Operator {

		// maths
		case "+":
			e.emit(code.OpAdd)
		case "-":
			e.emit(code.OpSub)
		case "*":
			e.emit(code.OpMul)
		case "/":
			e.emit(code.OpDiv)
		case "%":
			e.emit(code.OpMod)
		case "**":
			e.emit(code.OpPower)

			// comparisons
		case "<":
			e.emit(code.OpLess)
		case "<=":
			e.emit(code.OpLessEqual)
		case ">":
			e.emit(code.OpGreater)
		case ">=":
			e.emit(code.OpGreaterEqual)
		case "==":
			e.emit(code.OpEqual)
		case "!=":
			e.emit(code.OpNotEqual)
		case "~=":
			e.emit(code.OpMatches)
		case "!~":
			e.emit(code.OpNotMatches)

			// logical
		case "&&":
			e.emit(code.OpAnd)
		case "||":
			e.emit(code.OpOr)
		default:
			return fmt.Errorf("unknown operator %s", node.Operator)
		}

	case *ast.PrefixExpression:
		err := e.compile(node.Right)
		if err != nil {
			return err
		}

		switch node.Operator {
		case "!":
			e.emit(code.OpBang)
		case "-":
			e.emit(code.OpMinus)
		case "√":
			e.emit(code.OpRoot)
		default:
			return fmt.Errorf("unknown operator %s", node.Operator)
		}

	case *ast.IfExpression:

		// Compile the expression.
		err := e.compile(node.Condition)
		if err != nil {
			return err
		}

		//
		//  Assume the following input:
		//
		//    if ( blah ) {
		//       // A
		//    }
		//    else {
		//       // B
		//    }
		//    // C
		//
		// We've now compiled `blah`, which is the expression
		// above.
		//
		// So now we generate an `OpJumpIfFalse` to handle the case
		// where the if statement is not true. (If the `blah` condition
		// was true we just continue running it ..)
		//
		// Then the jump we're generating here will jump to either
		// B - if there is an else-block - or C if there is not.
		//
		jumpNotTruthyPos := e.emit(code.OpJumpIfFalse, 9999)

		//
		// Compile the code in block A
		//
		err = e.compile(node.Consequence)
		if err != nil {
			return err
		}

		//
		// Here we're calculating the length END of A.
		//
		// Because if the expression was false we want to
		// jump to the START of B.
		//
		afterConsequencePos := len(e.instructions)
		e.changeOperand(jumpNotTruthyPos, afterConsequencePos)

		//
		// If we don't have an `else` block then we're done.
		//
		// If we do then the end of the A-block needs to jump
		// to C - to skip over the else-branch.
		//
		// If there is no else block then we're all good, we only
		// needed to jump over the first block if the condition
		// was not true - and we've already handled that case.
		//
		if node.Alternative != nil {

			//
			// Add a jump to the end of A - which will
			// take us to C.
			//
			// Emit an `OpJump` with a bogus value
			jumpPos := e.emit(code.OpJump, 9999)

			//
			// We're jumping to the wrong place here,
			// so we have to cope with the updated target
			//
			// (We're in the wrong place because we just
			// added a JUMP at the end of A)
			//
			afterConsequencePos = len(e.instructions)
			e.changeOperand(jumpNotTruthyPos, afterConsequencePos)

			//
			// Compile the block
			//
			err := e.compile(node.Alternative)
			if err != nil {
				return err
			}

			//
			// Now we change the offset to be C, which
			// is the end of B.
			//
			afterAlternativePos := len(e.instructions)
			e.changeOperand(jumpPos, afterAlternativePos)
		}

		//
		// Hopefully that is clear.
		//
		// We end up with a simple case where there is no else-clause:
		//
		//   if ..
		//     JUMP IF NOT B:
		//     body
		//     body
		// B:
		//
		// And when there are both we have a pair of jumps:
		//
		//   if ..
		//     JUMP IF NOT B:
		//     body
		//     body
		//     JUMP C:
		//
		//  B: // else clause
		//     body
		//     body
		//     // fall-through
		//  C:
		//

	case *ast.AssignStatement:

		// Get the value
		err := e.compile(node.Value)
		if err != nil {
			return err
		}

		// Store the name
		str := &object.String{Value: node.Name.String()}
		e.emit(code.OpConstant, e.addConstant(str))

		// And make it work.
		e.emit(code.OpSet)

	case *ast.Identifier:
		str := &object.String{Value: node.Value}
		e.emit(code.OpLookup, e.addConstant(str))

	case *ast.CallExpression:

		//
		// call to print(1) will have the stack setup as:
		//
		//  1
		//  print
		//  call 1
		//
		// call to print( "steve", "kemp" ) will have:
		//
		//  "steve"
		//  "kemp"
		//  "print"
		//  call 2
		//
		args := len(node.Arguments)
		for _, a := range node.Arguments {

			err := e.compile(a)
			if err != nil {
				return err
			}
		}

		// call - has the string on the stack
		str := &object.String{Value: node.Function.String()}
		e.emit(code.OpConstant, e.addConstant(str))

		// then a call instruction with the number of args.
		e.emit(code.OpCall, args)

	default:
		return fmt.Errorf("unknown node type %T %v", node, node)
	}
	return nil
}

// addConstant adds a constant to the pool
func (e *Eval) addConstant(obj object.Object) int {

	//
	// Look to see if the constant is present already
	//
	for i, c := range e.constants {

		//
		// If the existing constant has the same
		// type and value - then return the offset.
		//
		if c.Type() == obj.Type() &&
			c.Inspect() == obj.Inspect() {
			return i
		}
	}

	//
	// Otherwise this is a distinct constant and should
	// be added.
	//
	e.constants = append(e.constants, obj)
	return len(e.constants) - 1
}

// emit generates a bytecode operation, and adds it to our program-array.
func (e *Eval) emit(op code.Opcode, operands ...int) int {

	ins := make([]byte, 1)
	ins[0] = byte(op)

	if len(operands) == 1 {

		// Make a buffer for the arg
		b := make([]byte, 2)
		binary.BigEndian.PutUint16(b, uint16(operands[0]))

		// append
		ins = append(ins, b...)
	}

	posNewInstruction := len(e.instructions)
	e.instructions = append(e.instructions, ins...)

	return posNewInstruction
}

// changeOperand is designed to patch the operand of
// and instruction.  It is basically used to rewrite the target
// of our jump instructions in the handling of `if`.
func (e *Eval) changeOperand(opPos int, operand int) {

	// get the opcode
	op := code.Opcode(e.instructions[opPos])

	// make a new buffer for the opcode
	ins := make([]byte, 1)
	ins[0] = byte(op)

	// Make a buffer for the arg
	b := make([]byte, 2)
	binary.BigEndian.PutUint16(b, uint16(operand))

	// append argument
	ins = append(ins, b...)

	// replace
	e.replaceInstruction(opPos, ins)
}

// replaceInstruction rewrites the instruction at the given
// bytecode position.
func (e *Eval) replaceInstruction(pos int, newInstruction []byte) {
	ins := e.instructions

	for i := 0; i < len(newInstruction); i++ {
		ins[pos+i] = newInstruction[i]
	}
}
